        -:    0:Source:linked_list.c
        -:    0:Graph:linked_list.gcno
        -:    0:Data:linked_list.gcda
        -:    0:Runs:1
        -:    1:#include <stdlib.h>
        -:    2:#include "linked_list.h"
        -:    3:#include "iterator.h"
        -:    4:#include "common.h"
        -:    5:#include <stdio.h>
        -:    6:#include <stdbool.h>
        -:    7:#include <string.h>
        -:    8:
        -:    9:typedef struct link link_t;
        -:   10:
        -:   11:struct link
        -:   12:{
        -:   13:    elem_t value;
        -:   14:    struct link *next;
        -:   15:};
        -:   16:struct list
        -:   17:{
        -:   18:    link_t *first;
        -:   19:    link_t *last;
        -:   20:    size_t size;
        -:   21:    ioopm_eq_function eq_fun; 
        -:   22:};
        -:   23:
        -:   24:struct iter
        -:   25:{
        -:   26:    link_t *current;
        -:   27:    ioopm_list_t *list;
        -:   28:};
        -:   29:
       17:   30:ioopm_list_t *ioopm_linked_list_create(ioopm_eq_function eq_fun)
        -:   31:{
       17:   32:    ioopm_list_t *list = calloc(1, sizeof(struct list));
       17:   33:    list->eq_fun = eq_fun; 
       17:   34:    return list; 
        -:   35:}
        -:   36:
       17:   37:void ioopm_linked_list_destroy(ioopm_list_t *list)
        -:   38:{
       17:   39:    if (!ioopm_linked_list_is_empty(list))
        -:   40:    {
       15:   41:        ioopm_linked_list_clear(list);
        -:   42:    }
       17:   43:    free(list);
       17:   44:}
        -:   45:
       72:   46:static link_t *link_create(elem_t value, link_t *next)
        -:   47:{
       72:   48:    link_t *new_link = calloc(1, sizeof(link_t));
       72:   49:    new_link->value = value;
       72:   50:    new_link->next = next;
       72:   51:    return new_link;
        -:   52:}
        -:   53:
       55:   54:void ioopm_linked_list_append(ioopm_list_t *list, elem_t value)
        -:   55:{
       55:   56:    link_t *new_link = link_create(value, NULL);
        -:   57:
       55:   58:    if (new_link != NULL) // check if mem was allocated correctly
        -:   59:    {
       55:   60:        if (list->last == NULL)
        -:   61:        {
        -:   62:            // if empty list
       14:   63:            list->first = new_link;
        -:   64:        }
        -:   65:        else
        -:   66:        {
        -:   67:            // if non-empty list
       41:   68:            list->last->next = new_link;
        -:   69:        }
        -:   70:
       55:   71:        list->last = new_link;
       55:   72:        list->size++;
        -:   73:    }
       55:   74:}
        -:   75:
       13:   76:void ioopm_linked_list_prepend(ioopm_list_t *list, elem_t value)
        -:   77:{
       13:   78:    link_t *new_link = link_create(value, list->first);
        -:   79:
       13:   80:    if (new_link != NULL) // check if mem was allocated correctly
        -:   81:    {
       13:   82:        list->first = new_link;
        -:   83:
       13:   84:        if (list->last == NULL)
        -:   85:        {
        -:   86:            // if empty list
        2:   87:            list->last = new_link;
        -:   88:        }
        -:   89:
       13:   90:        list->size++;
        -:   91:    }
       13:   92:}
        -:   93:
        7:   94:void ioopm_linked_list_insert(ioopm_list_t *list, int index, elem_t value)
        -:   95:{
        7:   96:    link_t *current = list->first;
        7:   97:    int counter = 0;
        7:   98:    size_t linked_list_size = ioopm_linked_list_size(list);
        -:   99:
        7:  100:    if (index < 0 || index > linked_list_size)
        -:  101:    {
        1:  102:        return; 
        -:  103:    }
        6:  104:    else if (index == 0)
        -:  105:    {
        1:  106:        ioopm_linked_list_prepend(list, value);
        -:  107:    }
        5:  108:    else if (index == linked_list_size)
        -:  109:    {
        1:  110:        ioopm_linked_list_append(list, value);
        -:  111:    }
        -:  112:    else
        -:  113:    {
       17:  114:        while (index > 0 && index < linked_list_size - 1 && counter <= index)
        -:  115:        {
       13:  116:            if (counter == index - 1)
        -:  117:            {
        4:  118:                link_t *new_link = link_create(value, NULL);
        4:  119:                link_t *tmp = current->next;
        4:  120:                current->next = new_link;
        4:  121:                new_link->next = tmp;
        4:  122:                list->size++;
        -:  123:            }
       13:  124:            counter++;
       13:  125:            current = current->next;
        -:  126:        }
        -:  127:    }
        -:  128:}
        -:  129:
        5:  130:elem_t ioopm_linked_list_remove(ioopm_list_t *list, int index)
        -:  131:{
        5:  132:    link_t *current = list->first;
        5:  133:    int counter = 0;
        5:  134:    size_t linked_list_size = ioopm_linked_list_size(list);
        5:  135:    elem_t value = {.string = "invalid input"};
        -:  136:
        5:  137:    if (list != NULL)
        -:  138:    {
        5:  139:        if (index < 0 || index >= linked_list_size)
        -:  140:        {
        1:  141:            return value; 
        -:  142:        }
        -:  143:        // first index
        4:  144:        else if (index == 0)
        -:  145:        {
        1:  146:            value = list->first->value;
        1:  147:            link_t *tmp = list->first->next;
        1:  148:            free(list->first);
        1:  149:            list->first = tmp;
        1:  150:            list->size--;
        -:  151:        }
        -:  152:        else
        -:  153:        {
       12:  154:            while (index > 0 && index < linked_list_size && counter < index)
        -:  155:            {
        -:  156:                // middle and last index
        9:  157:                if (counter == index - 1)
        -:  158:                {
        3:  159:                    value = current->next->value;
        3:  160:                    link_t *tmp = current->next->next;
        3:  161:                    free(current->next);
        3:  162:                    current->next = tmp;
        3:  163:                    list->size--;
        -:  164:                }
        -:  165:
        9:  166:                counter++;
        9:  167:                current = current->next;
        -:  168:            }
        -:  169:        }
        -:  170:    }
        4:  171:    return value;
        -:  172:}
        -:  173:
       72:  174:elem_t ioopm_linked_list_get(ioopm_list_t *list, int index)
        -:  175:{
       72:  176:    link_t *current = list->first;
       72:  177:    int counter = 0;
       72:  178:    if (index >= 0 && index < ioopm_linked_list_size(list)) // if correct index input
        -:  179:    {
      211:  180:        while (counter != index)
        -:  181:        {
      141:  182:            current = current->next;
      141:  183:            counter++;
        -:  184:        }
        -:  185:
       70:  186:        return current->value;
        -:  187:    }
        -:  188:    else
        -:  189:    {
        -:  190:        // invalid input
        2:  191:        elem_t invalid_out = {.string = "invalid input"}; 
        2:  192:        return invalid_out;
        -:  193:    }
        -:  194:}
        -:  195:
       12:  196:bool ioopm_linked_list_contains(ioopm_list_t *list, elem_t element)
        -:  197:{
       12:  198:    link_t *current = list->first;
        -:  199:
       30:  200:    while (current != NULL)
        -:  201:    {
       25:  202:        if (list->eq_fun(current->value, element)) // current->value == element)
        -:  203:        {
        7:  204:            return true;
        -:  205:        }
        -:  206:
       18:  207:        current = current->next;
        -:  208:    }
        -:  209:
        5:  210:    return false;
        -:  211:}
        -:  212:
       97:  213:size_t ioopm_linked_list_size(ioopm_list_t *list)
        -:  214:{
       97:  215:    return list->size;
        -:  216:}
        -:  217:
       21:  218:bool ioopm_linked_list_is_empty(ioopm_list_t *list)
        -:  219:{
       21:  220:    return list->size == 0;
        -:  221:}
        -:  222:
       16:  223:void ioopm_linked_list_clear(ioopm_list_t *list)
        -:  224:{
       16:  225:    link_t *current = list->first;
        -:  226:
       84:  227:    while (current != NULL)
        -:  228:    {
       68:  229:        link_t *next = current->next;
       68:  230:        free(current);
       68:  231:        current = next;
       68:  232:        list->size--;
        -:  233:    }
       16:  234:}
        -:  235:
        2:  236:bool ioopm_linked_list_all(ioopm_list_t *list, ioopm_int_predicate prop, void *extra)
        -:  237:{
        2:  238:    link_t *current = list->first;
        -:  239:
        8:  240:    while (current != NULL)
        -:  241:    {
        7:  242:        if (!prop(current->value, extra))
        -:  243:        {
        1:  244:            return false;
        -:  245:        }
        -:  246:
        6:  247:        current = current->next;
        -:  248:    }
        -:  249:
        1:  250:    return true;
        -:  251:}
        -:  252:
        2:  253:bool ioopm_linked_list_any(ioopm_list_t *list, ioopm_int_predicate prop, void *extra)
        -:  254:{
        2:  255:    link_t *current = list->first;
        -:  256:
        6:  257:    while (current != NULL)
        -:  258:    {
        5:  259:        if (prop(current->value, extra)) 
        -:  260:        {
        1:  261:            return true;
        -:  262:        }
        -:  263:
        4:  264:        current = current->next;
        -:  265:    }
        -:  266:
        1:  267:    return false;
        -:  268:}
        -:  269:
        1:  270:void ioopm_linked_list_apply_to_all(ioopm_list_t *list, ioopm_apply_int_function fun, void *extra)
        -:  271:{
        1:  272:    link_t *current = list->first;
        -:  273:
        5:  274:    while (current != NULL)
        -:  275:    {
        4:  276:        fun(&current->value, extra);
        4:  277:        current = current->next;
        -:  278:    }
        1:  279:}
        -:  280:
       15:  281:ioopm_list_iterator_t *ioopm_list_iterator(ioopm_list_t *list)
        -:  282:{
       15:  283:    ioopm_list_iterator_t *iter = calloc(1, sizeof(ioopm_list_iterator_t));
        -:  284:
       15:  285:    iter->list = list;
       15:  286:    iter->current = list->first;
        -:  287:
       15:  288:    return iter;
        -:  289:}
        -:  290:
       10:  291:bool ioopm_iterator_has_next(ioopm_list_iterator_t *iter)
        -:  292:{
       10:  293:    if (iter->current != NULL)
        -:  294:    {
        8:  295:        return iter->current->next != NULL;
        -:  296:    }
        -:  297:    else
        -:  298:    {
        2:  299:        return false; 
        -:  300:    }
        -:  301:}
        -:  302:
        7:  303:elem_t ioopm_iterator_next(ioopm_list_iterator_t *iter)
        -:  304:{
        7:  305:    if (!ioopm_iterator_has_next(iter))
        -:  306:    {
        1:  307:        elem_t error_out = {.integer = 0}; 
        1:  308:        return error_out;
        -:  309:    }
        -:  310:
        6:  311:    iter->current = iter->current->next;
        6:  312:    return iter->current->value;
        -:  313:}
        -:  314:
        3:  315:void ioopm_iterator_reset(ioopm_list_iterator_t *iter)
        -:  316:{
        3:  317:    if (iter->current != NULL)
        -:  318:    {
        2:  319:        iter->current = iter->list->first;
        -:  320:    }
        -:  321:    else
        -:  322:    {
        1:  323:        iter->list->first = NULL;
        -:  324:    }
        3:  325:}
        -:  326:
       11:  327:elem_t ioopm_iterator_current(ioopm_list_iterator_t *iter)
        -:  328:{
       11:  329:    if (iter->current != NULL)
        -:  330:    {
        8:  331:        return iter->current->value;
        -:  332:    }
        -:  333:    else
        -:  334:    {
        3:  335:        elem_t error_out = {.integer = 0}; 
        3:  336:        return error_out; 
        -:  337:    }
        -:  338:}
       15:  339:void ioopm_iterator_destroy(ioopm_list_iterator_t *iter)
        -:  340:{
       15:  341:    free(iter);
       15:  342:}
